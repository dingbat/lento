{"version":3,"sources":["parse.ts","compile.ts","play.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["grammar","ohm","semantics","createSemantics","addOperation","Composition","_1","statements","children","map","x","ast","settings","filter","type","sections","Instrument","header","_space","trackList","instrument","name","tracks","flat","TrackList","track","_bar","_bar2","sourceString","replaceAll","instrumentHeader","_slash","_2","Statement","setOrSection","_","set","_set","param","_to","_3","value","Number","Error","Arrangement","commandList","commands","CommandList","command","arrangementHeader","_slash2","Play","_play","fragment","times","_times","inlineThen","blockThen","parseInt","source","undefined","PlayNoBlockThen","InlineThen","_then","BlockThen","Loop","_loop","Fragment","reversed","ident","parse","code","match","e","succeeded","console","log","trace","toString","compile","error","message","main","find","s","bpmSet","reduce","section","bpm","SYNTH","Tone","toDestination","KIT","urls","A1","A2","A3","baseUrl","Playback","completionCallback","loop","note","currentLoop","complete","this","split","time","beat","reverse","triggerAttackRelease","length","Player","composition","playbacks","playSection","scheduleRepeat","forEach","playback","play","start","onComplete","commandFinished","pb","reset","stop","flatMap","playCommand","handleComplete","completeBlock","push","Main","styled","Editor","textarea","Preview","div","DEFAULT_TEXT","DEFAULT_COMPOSITION","App","useState","playing","setPlaying","setCode","started","setStarted","setComposition","togglePlay","a","cancel","onChange","target","autoCorrect","autoComplete","onClick","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.b4b1e75a.chunk.js","sourcesContent":["import ohm from \"ohm-js\";\nimport raw from \"raw.macro\";\nconst contents = raw(\"./grammar.ohm\");\n\nconst grammar = ohm.grammar(contents);\n\n(function(){})();\n\nexport interface Ast {\n  settings: Setting[];\n  sections: Section[];\n}\n\ntype Setting = { type: \"set\" } & (BpmSet | KeySet);\n\nexport interface BpmSet {\n  param: \"bpm\";\n  value: number;\n}\n\ninterface KeySet {\n  param: \"key\";\n  value: string;\n}\n\nexport type Section = InstrumentSection | ArrangementSection;\ntype Track = string;\n\ninterface InstrumentSection {\n  name: string;\n  type: \"instrument\";\n  instrument: string;\n  tracks: Track[];\n}\n\nexport interface ArrangementSection {\n  name: string;\n  type: \"arrangement\";\n  commands: Command[];\n}\n\nexport type Command = PlayCommand | LoopCommand;\n\ninterface PlayCommand {\n  type: \"play\";\n  times: number;\n  source: Source;\n  inlineThen?: Command;\n  blockThen?: Command;\n}\n\ninterface LoopCommand {\n  type: \"loop\";\n  source: Source;\n}\n\nexport type Source = { reversed: boolean } & (\n  | InlineTrackSource\n  | SectionSource\n);\n\ninterface InlineTrackSource {\n  type: \"inline_track\";\n  instrument: string;\n  track: Track;\n}\n\ninterface SectionSource {\n  type: \"section\";\n  name: string;\n}\n\nconst semantics = grammar.createSemantics().addOperation(\"ast\", {\n  Composition(_1, { children }): Ast {\n    const statements = children.map((x) => x.ast());\n    return {\n      settings: statements.filter((x) => x.type === \"set\"),\n      sections: statements.filter(\n        (x) => x.type === \"instrument\" || x.type === \"arrangement\"\n      ),\n    };\n  },\n  Instrument(header, _space, trackList): InstrumentSection {\n    const { instrument, name } = header.ast();\n    return {\n      type: \"instrument\",\n      instrument,\n      name,\n      tracks: trackList.ast().flat(),\n    };\n  },\n  TrackList(track, _1, tracks) {\n    return [track.ast(), ...tracks.ast()];\n  },\n  track(_bar, track, _bar2): Track {\n    return track.sourceString.replaceAll(\"|\", \"\");\n  },\n  instrumentHeader(_1, name, _slash, instrument, _2) {\n    return { name: name.sourceString, instrument: instrument.sourceString };\n  },\n  Statement(setOrSection, _) {\n    return setOrSection.ast();\n  },\n  set(_set, _1, param, _2, _to, _3, value): Setting {\n    switch (param.sourceString) {\n      case \"bpm\":\n        return { type: \"set\", param: \"bpm\", value: Number(value.sourceString) };\n      case \"key\":\n        return { type: \"set\", param: \"key\", value: value.sourceString };\n      default:\n        throw new Error(\"bpm or key expected\");\n    }\n  },\n\n  Arrangement(header, _1, commandList): ArrangementSection {\n    const { name } = header.ast();\n    return {\n      type: \"arrangement\",\n      name,\n      commands: commandList.ast().flat(),\n    };\n  },\n  CommandList(command, _1, commands) {\n    return [command.ast(), ...commands.ast()];\n  },\n  arrangementHeader(_1, name, _slash2) {\n    return { name: name.sourceString };\n  },\n  Play(_play, fragment, times, _times, inlineThen, _1, blockThen) {\n    return {\n      type: \"play\",\n      times: times.sourceString ? parseInt(times.sourceString) : 1,\n      source: fragment.ast(),\n      inlineThen: inlineThen.sourceString ? inlineThen.ast()[0] : undefined,\n      blockThen: blockThen.sourceString ? blockThen.ast()[0] : undefined,\n    };\n  },\n  PlayNoBlockThen(_play, fragment, times, _times, inlineThen) {\n    return {\n      type: \"play\",\n      times: times.sourceString ? parseInt(times.sourceString) : 1,\n      source: fragment.ast(),\n      inlineThen: inlineThen.sourceString ? inlineThen.ast()[0] : undefined,\n      blockThen: undefined,\n    };\n  },\n  InlineThen(_then, command) {\n    return command.ast();\n  },\n  BlockThen(_then, _1, command) {\n    return command.ast();\n  },\n  Loop(_loop, fragment) {\n    return {\n      type: \"loop\",\n      source: fragment.ast(),\n    };\n  },\n  Fragment(reversed, ident, track): Source {\n    if (track.sourceString) {\n      return {\n        type: \"inline_track\",\n        instrument: ident.sourceString,\n        track: track.ast()[0],\n        reversed: !!reversed.sourceString,\n      };\n    } else {\n      return {\n        type: \"section\",\n        name: ident.sourceString,\n        reversed: !!reversed.sourceString,\n      };\n    }\n  },\n});\n\nfunction parse(code: string): Ast | null {\n  let match;\n  try {\n    match = grammar.match(code);\n  } catch (e) {\n    return null;\n  }\n  if (match.succeeded()) {\n    return semantics(match).ast();\n  } else {\n    console.log(grammar.trace(code).toString());\n    return null;\n  }\n}\nexport default parse;\n","import parse, { Section, ArrangementSection, BpmSet } from \"./parse\";\n\ntype SectionMap = { [key: string]: Section };\n\nexport interface Composition {\n  error: false;\n  main: ArrangementSection;\n  sections: SectionMap;\n  bpm: number;\n}\n\nexport interface Error {\n  error: true;\n  message: string;\n}\n\nfunction compile(code: string): Composition | Error {\n  const ast = parse(code);\n  if (!ast) {\n    return { error: true, message: \"syntax error\" };\n  }\n  const main = ast.sections.find((s) => s.name === \"main\");\n  if (!main) {\n    return { error: true, message: \"no main/\" };\n  }\n  if (main.type !== \"arrangement\") {\n    return { error: true, message: \"main/ must be arrangement\" };\n  }\n  const bpmSet = ast.settings.find((s) => s.param === \"bpm\") as\n    | BpmSet\n    | undefined;\n\n  const sections: SectionMap = {};\n  const error = ast.sections.reduce<Error | null>((error, section) => {\n    if (sections[section.name]) {\n      return {\n        error: true,\n        message: `multiple sections named \"${section.name}\"`,\n      };\n    }\n    sections[section.name] = section;\n    return error;\n  }, null);\n  if (error) {\n    return error;\n  }\n  // check for instantaneous cycles (cycles in a then are ok)\n\n  return {\n    error: false,\n    main,\n    sections,\n    bpm: bpmSet?.value || 120,\n  };\n}\n\nexport default compile;\n","import * as Tone from \"tone\";\nimport { Command, ArrangementSection } from \"./parse\";\nimport { Composition } from \"./compile\";\n\nconst SYNTH = new Tone.PolySynth().toDestination();\nconst KIT = new Tone.Sampler({\n  urls: {\n    A1: \"kick.mp3\",\n    A2: \"snare.mp3\",\n    A3: \"hihat.mp3\",\n  },\n  baseUrl: \"https://tonejs.github.io/audio/drum-samples/breakbeat8/\",\n}).toDestination();\n\nclass Playback {\n  track: string[];\n  instrument: string;\n  reversed: boolean;\n  completionCallback: () => void;\n  note: number;\n  loop: number | boolean;\n  currentLoop: number | boolean;\n  complete: boolean;\n\n  constructor(\n    track: string,\n    instrument: string,\n    reversed: boolean,\n    completionCallback: () => void,\n    loop: number | boolean\n  ) {\n    this.track = track.split(\"\");\n    this.instrument = instrument;\n    this.reversed = reversed;\n    this.completionCallback = completionCallback;\n    this.loop = loop;\n    this.complete = false;\n    this.note = 0;\n    this.currentLoop = this.loop;\n  }\n\n  reset() {\n    this.complete = false;\n    this.note = 0;\n    this.currentLoop = this.loop;\n  }\n\n  play(time: number) {\n    const track = this.reversed ? this.track.reverse() : this.track;\n    const beat = track[this.note];\n    if (beat !== \"-\" && beat !== \".\") {\n      const length = \"4n\";\n      if (this.instrument === \"synth\") {\n        SYNTH.triggerAttackRelease(`${beat}4`, length, time);\n      } else {\n        const note = beat === \"k\" ? \"A1\" : beat === \"s\" ? \"A2\" : \"A3\";\n        KIT.triggerAttackRelease(note, length, time);\n      }\n    }\n    this.note = (this.note + 1) % this.track.length;\n    if (this.note === 0) {\n      if (typeof this.currentLoop === \"number\") {\n        this.currentLoop -= 1;\n      }\n      if (this.currentLoop === 0 || this.currentLoop === false) {\n        this.complete = true;\n        this.completionCallback();\n      }\n    }\n  }\n\n  stop() {\n    this.complete = true;\n  }\n}\n\nclass Player {\n  composition: Composition;\n  playbacks: Playback[];\n\n  constructor(composition: Composition) {\n    this.composition = composition;\n    this.playbacks = [];\n  }\n\n  play() {\n    Tone.Transport.bpm.value = this.composition.bpm;\n\n    this.playSection(this.composition.main, 1, () => {\n      console.log(\"done\");\n    });\n\n    Tone.Transport.scheduleRepeat((time) => {\n      this.playbacks.forEach((playback) => {\n        if (!playback.complete) {\n          playback.play(time + 0.1);\n        }\n      });\n    }, \"4n\");\n\n    Tone.Transport.start();\n  }\n\n  playSection(\n    section: ArrangementSection,\n    loop: boolean | number,\n    onComplete: () => void\n  ): Playback[] {\n    const commandFinished = () => {\n      if (loop === true) {\n        playbacks.forEach((pb) => pb.reset());\n      } else if (loop === false) {\n        playbacks.forEach((pb) => pb.stop());\n        onComplete();\n      } else {\n        loop -= 1;\n        if (loop === 0) {\n          playbacks.forEach((pb) => pb.stop());\n          onComplete();\n        } else {\n          playbacks.forEach((pb) => pb.reset());\n        }\n      }\n    };\n    const playbacks = section.commands.flatMap((command) => {\n      return this.playCommand(command, commandFinished);\n    });\n    return playbacks;\n  }\n\n  playCommand(command: Command, onComplete: () => void): Playback[] {\n    const { source } = command;\n    const loop = command.type === \"loop\" ? true : command.times;\n    const handleComplete = () => {\n      if (command.type === \"play\") {\n        const completeBlock = () => {\n          onComplete();\n          if (command.blockThen) {\n            this.playCommand(command.blockThen, () => {});\n          }\n        };\n        if (command.inlineThen) {\n          this.playCommand(command.inlineThen, completeBlock);\n        } else {\n          completeBlock();\n        }\n      }\n    };\n    if (source.type === \"inline_track\") {\n      const playback = new Playback(\n        source.track,\n        source.instrument,\n        source.reversed,\n        handleComplete,\n        loop\n      );\n      this.playbacks.push(playback);\n      return [playback];\n    } else {\n      const section = this.composition.sections[source.name];\n      if (section.type === \"arrangement\") {\n        return this.playSection(section, loop, handleComplete);\n      } else {\n        const playbacks = section.tracks.map((track) => {\n          return new Playback(\n            track,\n            section.instrument,\n            source.reversed,\n            handleComplete,\n            loop\n          );\n        });\n        this.playbacks.push(...playbacks);\n        return playbacks;\n      }\n    }\n  }\n}\n\nfunction play(composition: Composition) {\n  const player = new Player(composition);\n  player.play();\n}\n\nexport default play;\n","import { useState, ChangeEvent } from \"react\";\nimport styled from \"styled-components/macro\";\nimport compile, { Composition, Error } from \"./compile\";\nimport * as Tone from \"tone\";\nimport raw from \"raw.macro\";\nimport play from \"./play\";\n\nconst Main = styled.main`\n  display: flex;\n  width: 100%;\n  height: 100%;\n`;\nconst Editor = styled.textarea`\n  flex: 1;\n  flex-shrink: 0;\n  padding: 1rem;\n`;\nconst Preview = styled.div`\n  flex: 1;\n  padding: 2rem;\n`;\n\nconst DEFAULT_TEXT = raw(\"../default.txt\");\nconst DEFAULT_COMPOSITION = compile(DEFAULT_TEXT);\n\nfunction App() {\n  const [playing, setPlaying] = useState(false);\n  const [code, setCode] = useState(DEFAULT_TEXT);\n  const [started, setStarted] = useState(false);\n  const [composition, setComposition] = useState<Composition | Error>(DEFAULT_COMPOSITION);\n  const handleChange = (e: ChangeEvent<HTMLTextAreaElement>) => {\n    if (playing) {\n      togglePlay();\n    }\n    setCode(e.target.value);\n    const composition = compile(e.target.value + \"\\n\");\n    setComposition(composition);\n  };\n  const togglePlay = async () => {\n    if (playing) {\n      Tone.Transport.stop();\n      Tone.Transport.cancel();\n      setPlaying(false);\n    } else {\n      if (!started) {\n        await Tone.start();\n      }\n      setStarted(true);\n      if (!composition.error) {\n        play(composition);\n        setPlaying(true);\n      }\n    }\n  };\n  return (\n    <Main>\n      <Editor\n        value={code}\n        onChange={handleChange}\n        autoCorrect=\"none\"\n        autoComplete=\"none\"\n      />\n      <Preview>\n        <button onClick={togglePlay}>{playing ? \"stop\" : \"play\"}</button>\n        {composition.error && composition.message}\n      </Preview>\n    </Main>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}