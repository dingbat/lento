{"version":3,"sources":["parse.ts","compile.ts","play.ts","highlighter.ts","App.tsx","useCodeMirror.tsx","reportWebVitals.ts","index.tsx"],"names":["grammar","ohm","semantics","createSemantics","addOperation","Composition","_1","statements","children","map","x","ast","settings","filter","type","sections","Instrument","header","_space","trackList","instrument","name","tracks","flat","TrackList","track","_bar","_bar2","sourceString","replaceAll","instrumentHeader","_slash","_2","Statement","setOrSection","_","set","_set","param","_to","_3","value","Number","Error","Arrangement","commandList","commands","CommandList","command","arrangementHeader","_slash2","Play","_play","fragment","times","inlineThen","blockThen","parseInt","source","undefined","PlayNoBlockThen","InlineThen","_then","BlockThen","Loop","_loop","Fragment","reversed","ident","parse","code","match","e","error","message","succeeded","checkInstrument","includes","checkSection","section","initialError","checked","checkDefinedSections","reduce","setMain","forEach","inMain","compile","syntaxError","main","find","s","bpmSet","error2","bpm","SYNTH","Tone","toDestination","KIT","urls","A1","A2","A3","baseUrl","Playback","completionCallback","loop","note","currentLoop","complete","this","split","reverse","time","beat","triggerAttackRelease","length","Player","composition","playbacks","onComplete","playSection","scheduleRepeat","callbacks","playback","play","push","c","start","allowInfiniteLoops","playCommands","commandFinished","every","p","pb","reset","stop","flatMap","playCommand","handleComplete","completeBlock","individualTrackComplete","language","StreamLanguage","define","languageData","commentTokens","line","token","stream","tag","previousString","string","substring","pos","boundary","backUp","next","Main","styled","Editor","div","Preview","SyntaxError","DEFAULT_TEXT","DEFAULT_COMPOSITION","App","useState","playing","setPlaying","started","setStarted","setComposition","togglePlay","a","cancel","editor","options","element","useRef","view","useReducer","state","transaction","newState","update","docChanged","callback","sliceDoc","EditorState","create","doc","extensions","basicSetup","highlighter","oneDark","keymap","of","commentKeymap","dispatch","useEffect","current","setState","EditorView","parent","container","destroy","useCodeMirror","ref","onClick","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.de10ad47.chunk.js","sourcesContent":["import ohm from \"ohm-js\";\nimport raw from \"raw.macro\";\nconst contents = raw(\"./grammar.ohm\");\n\nconst grammar = ohm.grammar(contents);\n\n(function(){})();\n\nexport interface Ast {\n  settings: Setting[];\n  sections: Section[];\n}\n\ntype Setting = { type: \"set\" } & (BpmSet | KeySet);\n\nexport interface BpmSet {\n  param: \"bpm\";\n  value: number;\n}\n\ninterface KeySet {\n  param: \"key\";\n  value: string;\n}\n\nexport type Section = InstrumentSection | ArrangementSection;\ntype Track = string;\n\ninterface InstrumentSection {\n  name: string;\n  type: \"instrument\";\n  instrument: string;\n  tracks: Track[];\n}\n\nexport interface ArrangementSection {\n  name: string;\n  type: \"arrangement\";\n  commands: Command[];\n  checked?: boolean;\n}\n\nexport type Command = PlayCommand | LoopCommand;\n\nexport interface PlayCommand {\n  type: \"play\";\n  times: number;\n  source: Source;\n  inlineThen?: Command;\n  blockThen?: Command[];\n  inMain: boolean;\n}\n\ninterface LoopCommand {\n  type: \"loop\";\n  source: Source;\n}\n\nexport type Source = { reversed: boolean } & (\n  | InlineTrackSource\n  | SectionSource\n);\n\ninterface InlineTrackSource {\n  type: \"inline_track\";\n  instrument: string;\n  track: Track;\n}\n\ninterface SectionSource {\n  type: \"section\";\n  name: string;\n}\n\nconst semantics = grammar.createSemantics().addOperation(\"ast\", {\n  Composition(_1, { children }): Ast {\n    const statements = children.map((x) => x.ast());\n    return {\n      settings: statements.filter((x) => x.type === \"set\"),\n      sections: statements.filter(\n        (x) => x.type === \"instrument\" || x.type === \"arrangement\"\n      ),\n    };\n  },\n  Instrument(header, _space, trackList): InstrumentSection {\n    const { instrument, name } = header.ast();\n    return {\n      type: \"instrument\",\n      instrument,\n      name,\n      tracks: trackList.ast().flat(),\n    };\n  },\n  TrackList(track, _1, tracks) {\n    return [track.ast(), ...tracks.ast()];\n  },\n  track(_bar, track, _bar2): Track {\n    return track.sourceString.replaceAll(\"|\", \"\");\n  },\n  instrumentHeader(_1, name, _slash, instrument, _2) {\n    return { name: name.sourceString, instrument: instrument.sourceString };\n  },\n  Statement(setOrSection, _) {\n    return setOrSection.ast();\n  },\n  set(_set, _1, param, _2, _to, _3, value): Setting {\n    switch (param.sourceString) {\n      case \"bpm\":\n        return { type: \"set\", param: \"bpm\", value: Number(value.sourceString) };\n      case \"key\":\n        return { type: \"set\", param: \"key\", value: value.sourceString };\n      default:\n        throw new Error(\"bpm or key expected\");\n    }\n  },\n\n  Arrangement(header, _1, commandList): ArrangementSection {\n    const { name } = header.ast();\n    return {\n      type: \"arrangement\",\n      name,\n      commands: commandList.ast().flat(),\n    };\n  },\n  CommandList(command, _1, commands) {\n    return [command.ast(), ...commands.ast()];\n  },\n  arrangementHeader(_1, name, _slash2) {\n    return { name: name.sourceString };\n  },\n  Play(_play, fragment, times, inlineThen, _1, blockThen) {\n    return {\n      type: \"play\",\n      times: times.sourceString ? parseInt(times.sourceString) : 1,\n      source: fragment.ast(),\n      inlineThen: inlineThen.sourceString ? inlineThen.ast()[0] : undefined,\n      blockThen: blockThen.sourceString ? blockThen.ast()[0] : undefined,\n    };\n  },\n  PlayNoBlockThen(_play, fragment, times, inlineThen) {\n    return {\n      type: \"play\",\n      times: times.sourceString ? parseInt(times.sourceString) : 1,\n      source: fragment.ast(),\n      inlineThen: inlineThen.sourceString ? inlineThen.ast()[0] : undefined,\n      blockThen: undefined,\n    };\n  },\n  InlineThen(_then, command) {\n    return command.ast();\n  },\n  BlockThen(_then, _1, commandList) {\n    return commandList.ast().flat();\n  },\n  Loop(_loop, fragment) {\n    return {\n      type: \"loop\",\n      source: fragment.ast(),\n    };\n  },\n  Fragment(reversed, ident, track): Source {\n    if (track.sourceString) {\n      return {\n        type: \"inline_track\",\n        instrument: ident.sourceString,\n        track: track.ast()[0],\n        reversed: !!reversed.sourceString,\n      };\n    } else {\n      return {\n        type: \"section\",\n        name: ident.sourceString,\n        reversed: !!reversed.sourceString,\n      };\n    }\n  },\n});\n\nfunction parse(code: string): { ast: Ast | null; error: string | null } {\n  let match;\n  try {\n    match = grammar.match(code);\n  } catch (e) {\n    return { ast: null, error: e.message };\n  }\n  if (match.succeeded()) {\n    return { ast: semantics(match).ast(), error: null };\n  } else {\n    return { ast: null, error: match.message || \"\" };\n  }\n}\nexport default parse;\n","import parse, { Section, Command, ArrangementSection, BpmSet } from \"./parse\";\n\ntype SectionMap = { [key: string]: Section };\n\nexport interface Composition {\n  error: false;\n  main: ArrangementSection;\n  sections: SectionMap;\n  bpm: number;\n}\n\nexport interface Error {\n  error: true;\n  message: string;\n}\n\nfunction checkInstrument(instrument: string): Error | null {\n  if ([\"synth\", \"kit\"].includes(instrument)) {\n    return null;\n  }\n  return {\n    error: true,\n    message: \"only instruments are `synth` and `kit`\",\n  };\n}\n\nfunction checkSection(\n  sections: SectionMap,\n  section: ArrangementSection,\n  initialError?: Error | null\n): Error | null {\n  if (section.checked) {\n    return initialError || null;\n  }\n  section.checked = true;\n  return checkDefinedSections(sections, section.commands, initialError);\n}\n\nfunction checkDefinedSections(\n  sections: SectionMap,\n  commands: Command[],\n  initialError?: Error | null\n): Error | null {\n  return commands.reduce<Error | null>((error, command) => {\n    if (command.source.type === \"inline_track\") {\n      return error || checkInstrument(command.source.instrument);\n    } else {\n      const section = sections[command.source.name];\n      if (!section) {\n        return {\n          error: true,\n          message: `section \"${command.source.name}\" not defined`,\n        };\n      } else {\n        if (section.type === \"arrangement\") {\n          error = checkSection(sections, section, error);\n        } else {\n          error = error || checkInstrument(section.instrument);\n        }\n        if (command.type === \"play\") {\n          if (command.inlineThen) {\n            error = checkDefinedSections(sections, [command.inlineThen], error);\n          }\n          if (command.blockThen) {\n            error = checkDefinedSections(sections, command.blockThen, error);\n          }\n        }\n        return error;\n      }\n    }\n  }, initialError || null);\n}\n\nfunction setMain(commands: Command[]) {\n  commands.forEach((command) => {\n    if (command.type === \"play\") {\n      command.inMain = true;\n      if (command.inlineThen) {\n        setMain([command.inlineThen]);\n      }\n      if (command.blockThen) {\n        setMain(command.blockThen);\n      }\n    }\n  });\n}\n\nfunction compile(code: string): Composition | Error {\n  const { ast, error: syntaxError } = parse(code);\n  if (!ast) {\n    return { error: true, message: \"syntax error: \" + syntaxError };\n  }\n  const main = ast.sections.find((s) => s.name === \"main\");\n  if (!main) {\n    return { error: true, message: \"no main/\" };\n  }\n  if (main.type !== \"arrangement\") {\n    return { error: true, message: \"main/ must be arrangement\" };\n  }\n  const bpmSet = ast.settings.find((s) => s.param === \"bpm\") as\n    | BpmSet\n    | undefined;\n\n  const sections: SectionMap = {};\n  const error = ast.sections.reduce<Error | null>((error, section) => {\n    if (sections[section.name]) {\n      return {\n        error: true,\n        message: `multiple sections named \"${section.name}\"`,\n      };\n    }\n    sections[section.name] = section;\n    return error;\n  }, null);\n\n  if (error) {\n    return error;\n  }\n\n  setMain(main.commands);\n  const error2 = checkSection(sections, main);\n  if (error2) {\n    return error2;\n  }\n  // check for instantaneous cycles (cycles in a then are ok)\n\n  return {\n    error: false,\n    main,\n    sections,\n    bpm: bpmSet?.value || 120,\n  };\n}\n\nexport default compile;\n","import * as Tone from \"tone\";\nimport { Command, ArrangementSection } from \"./parse\";\nimport { Composition } from \"./compile\";\n\nconst SYNTH = new Tone.PolySynth().toDestination();\nconst KIT = new Tone.Sampler({\n  urls: {\n    A1: \"kick.mp3\",\n    A2: \"snare.mp3\",\n    A3: \"hihat.mp3\",\n  },\n  baseUrl: \"https://tonejs.github.io/audio/drum-samples/breakbeat8/\",\n}).toDestination();\n\nclass Playback {\n  track: string[];\n  instrument: string;\n  completionCallback: () => void;\n  note: number;\n  loop: number | boolean;\n  currentLoop: number | boolean;\n  complete: boolean;\n\n  constructor(\n    track: string,\n    instrument: string,\n    reversed: boolean,\n    completionCallback: () => void,\n    loop: number | boolean\n  ) {\n    this.track = track.split(\"\");\n    if (reversed) {\n      this.track = this.track.reverse();\n    }\n    this.instrument = instrument;\n    this.completionCallback = completionCallback;\n    this.loop = loop;\n    this.complete = false;\n    this.note = 0;\n    this.currentLoop = this.loop;\n  }\n\n  reset() {\n    this.complete = false;\n    this.note = 0;\n    this.currentLoop = this.loop;\n  }\n\n  play(time: number) {\n    const beat = this.track[this.note];\n    if (beat !== \"-\" && beat !== \".\") {\n      const length = \"4n\";\n      if (this.instrument === \"synth\") {\n        SYNTH.triggerAttackRelease(`${beat}4`, length, time);\n      } else {\n        const note = beat === \"k\" ? \"A1\" : beat === \"s\" ? \"A2\" : \"A3\";\n        KIT.triggerAttackRelease(note, length, time);\n      }\n    }\n    this.note = (this.note + 1) % this.track.length;\n    if (this.note === 0) {\n      if (typeof this.currentLoop === \"number\") {\n        this.currentLoop -= 1;\n      }\n      if (this.currentLoop <= 0 || this.currentLoop === false) {\n        this.complete = true;\n      }\n    }\n  }\n\n  stop() {\n    this.complete = true;\n  }\n}\n\nclass Player {\n  composition: Composition;\n  playbacks: Playback[];\n\n  constructor(composition: Composition) {\n    this.composition = composition;\n    this.playbacks = [];\n  }\n\n  play(onComplete: () => void) {\n    Tone.Transport.bpm.value = this.composition.bpm;\n\n    this.playSection(this.composition.main, 1, false, onComplete, true);\n\n    Tone.Transport.scheduleRepeat((time) => {\n      let callbacks: (() => void)[] = [];\n      this.playbacks.forEach((playback) => {\n        if (!playback.complete) {\n          playback.play(time + 0.1);\n          if (playback.complete) {\n            callbacks.push(playback.completionCallback);\n          }\n        }\n      });\n      callbacks.forEach((c) => c());\n    }, \"4n\");\n\n    Tone.Transport.start();\n  }\n\n  playSection(\n    section: ArrangementSection,\n    loop: boolean | number,\n    reversed: boolean,\n    onComplete: () => void,\n    allowInfiniteLoops = false\n  ): Playback[] {\n    return this.playCommands(\n      section.commands,\n      loop,\n      reversed,\n      onComplete,\n      allowInfiniteLoops\n    );\n  }\n\n  playCommands(\n    commands: Command[],\n    loop: boolean | number,\n    reversed: boolean,\n    onComplete: () => void,\n    allowInfiniteLoops = false\n  ): Playback[] {\n    const commandFinished = () => {\n      const allPlaybackComplete = playbacks.every(\n        (p) => (p.loop === true) || p.complete\n      );\n      if (allPlaybackComplete) {\n        if (typeof loop === \"number\") {\n          loop -= 1;\n        }\n        if (loop === true) {\n          playbacks.forEach((pb) => pb.reset());\n        } else if (loop === false || loop <= 0) {\n          playbacks.forEach((pb) => pb.stop());\n          onComplete();\n        } else {\n          playbacks.forEach((pb) => pb.reset());\n        }\n      }\n    };\n    const playbacks = commands.flatMap((command) => {\n      return this.playCommand(command, reversed, commandFinished);\n    });\n    return playbacks;\n  }\n\n  playCommand(\n    command: Command,\n    reversed: boolean,\n    onComplete: () => void\n  ): Playback[] {\n    const { source } = command;\n    reversed = reversed ? !source.reversed : source.reversed;\n    const loop = command.type === \"loop\" ? true : command.times;\n    const handleComplete = () => {\n      if (command.type === \"play\") {\n        const completeBlock = () => {\n          if (command.blockThen) {\n            this.playCommands(\n              command.blockThen,\n              false,\n              false,\n              onComplete,\n              command.inMain\n            );\n          } else {\n            onComplete();\n          }\n        };\n        if (command.inlineThen) {\n          this.playCommand(command.inlineThen, false, completeBlock);\n        } else {\n          completeBlock();\n        }\n      }\n    };\n    if (source.type === \"inline_track\") {\n      const playback = new Playback(\n        source.track,\n        source.instrument,\n        reversed,\n        handleComplete,\n        loop\n      );\n      this.playbacks.push(playback);\n      return [playback];\n    } else {\n      const section = this.composition.sections[source.name];\n      if (section.type === \"arrangement\") {\n        return this.playSection(section, loop, reversed, handleComplete);\n      } else {\n        const individualTrackComplete = () => {\n          const allPlaybackComplete = playbacks.every((p) => p.complete);\n          if (allPlaybackComplete) {\n            handleComplete();\n          }\n        };\n        const playbacks = section.tracks.map((track) => {\n          return new Playback(\n            track,\n            section.instrument,\n            reversed,\n            individualTrackComplete,\n            loop\n          );\n        });\n        this.playbacks.push(...playbacks);\n        return playbacks;\n      }\n    }\n  }\n}\n\nfunction play(composition: Composition, onComplete: () => void) {\n  const player = new Player(composition);\n  player.play(onComplete);\n}\n\nexport default play;\n","import { StreamLanguage } from \"@codemirror/stream-parser\";\n\nconst language = StreamLanguage.define({\n  languageData: {\n    commentTokens: {\n      line: \"#\",\n    },\n  },\n  token: function (stream) {\n    let tag = \"\";\n    const previousString = stream.string.substring(0, stream.pos);\n    const boundary = previousString.match(/(^| )$/);\n    if (boundary && stream.match(/^(loop|play|set|to)( |$)/)) {\n      stream.backUp(1);\n      tag = \"keyword\";\n    } else if (boundary && stream.match(/^then( |$)/)) {\n      stream.backUp(1);\n      tag = \"strong\";\n    } else if (boundary && stream.match(/^\\d+ times/)) {\n      stream.backUp(1);\n      tag = \"bool\";\n    } else if (boundary && stream.match(/reversed( |$)/)) {\n      stream.backUp(1);\n      tag = \"bool\";\n    } else if (previousString.match(/ *set +$/)) {\n      // set statement parameter\n      stream.match(/^[a-z]+/);\n    } else if (previousString.match(/ +to +$/) && stream.match(/^[^# ]*/)) {\n      // set statement value\n      stream.backUp(1);\n      tag = \"character\";\n    } else if (stream.match(/^#.*/)) {\n      tag = \"comment\";\n    } else if (previousString.match(/\\|$/) && stream.match(/^[^|#]+\\|/)) {\n      // track notes\n      tag = \"labelName\";\n      stream.backUp(1);\n    } else if (stream.match(/^\\|/)) {\n      // track bar\n      tag = \"meta\";\n      stream.backUp(1);\n    } else if (stream.match(/^[^/]+\\//)) {\n      // section name\n      stream.backUp(2);\n      tag = \"strong\";\n    } else if (previousString.match(/\\/$/) && stream.match(/^[^#]+/)) {\n      stream.backUp(1);\n      tag = \"emphasis\";\n    } else if (previousString.match(/^[^|]*$/) && stream.match(/^[^ |]+ *\\|/)) {\n      // inline instrument\n      stream.backUp(2);\n      tag = \"emphasis\";\n    }\n    stream.next();\n    return tag;\n  },\n});\n\nexport default language;\n","import { useState } from \"react\";\nimport styled from \"styled-components/macro\";\nimport compile, { Composition, Error } from \"./compile\";\nimport * as Tone from \"tone\";\nimport raw from \"raw.macro\";\nimport play from \"./play\";\nimport useCodeMirror from \"./useCodeMirror\";\n\nconst Main = styled.main`\n  display: flex;\n  width: 100%;\n  height: 100%;\n`;\nconst Editor = styled.div`\n  flex: 2;\n  flex-shrink: 0;\n`;\nconst Preview = styled.div`\n  flex: 1;\n  padding: 2rem;\n  background-color: rgb(30,30,30);\n`;\nconst SyntaxError = styled.div`\n  color: red;\n`;\nconst DEFAULT_TEXT = `\nset bpm to 180\n\nbeat/kit\n|hhhh|\n|k.k.|\n|..s.|..ss|\n\nmelody/synth\n|..ab|..dd|eg..|geab|\n\na/\nplay melody then play b\n\nb/\nplay beat then play a\n\nmain/\nplay beat\n` && raw(\"../default.txt\");\nconst DEFAULT_COMPOSITION = compile(DEFAULT_TEXT);\n\n(() => {})();\n\nfunction App() {\n  const [playing, setPlaying] = useState(false);\n  const [started, setStarted] = useState(false);\n  const [composition, setComposition] = useState<Composition | Error>(\n    DEFAULT_COMPOSITION\n  );\n\n  const togglePlay = async () => {\n    if (playing) {\n      Tone.Transport.stop();\n      Tone.Transport.cancel();\n      setPlaying(false);\n    } else {\n      if (!started) {\n        await Tone.start();\n      }\n      setStarted(true);\n      if (!composition.error) {\n        play(composition, () => setPlaying(false));\n        setPlaying(true);\n      }\n    }\n  };\n\n  const handleChange = (code: string) => {\n    if (playing) {\n      togglePlay();\n    }\n    const composition = compile(code + \"\\n\");\n    setComposition(composition);\n  };\n  const editor = useCodeMirror<HTMLDivElement>({\n    doc: DEFAULT_TEXT,\n    callback: handleChange,\n  });\n\n  return (\n    <Main>\n      <Editor ref={editor} />\n      <Preview>\n        <button onClick={togglePlay}>{playing ? \"stop\" : \"play\"}</button>\n        <SyntaxError><pre>{composition.error && composition.message}</pre></SyntaxError>\n      </Preview>\n    </Main>\n  );\n}\n\nexport default App;\n","import { basicSetup, EditorState, EditorView } from \"@codemirror/basic-setup\";\nimport { Transaction, Text } from \"@codemirror/state\";\nimport { keymap } from \"@codemirror/view\";\nimport { commentKeymap } from \"@codemirror/comment\";\nimport { MutableRefObject, useEffect, useReducer, useRef } from \"react\";\nimport { oneDark } from \"@codemirror/theme-one-dark\";\n\nimport highlighter from \"./highlighter\";\n\ninterface Options {\n  doc?: string | Text;\n  callback?: (newDoc: string) => void;\n}\n\nexport default function useCodeMirror<T extends Element>(\n  options: Options = {}\n): MutableRefObject<T | null> {\n  const element = useRef<T | null>(null);\n  const view = useRef<EditorView | null>(null);\n\n  const [state, dispatch] = useReducer(\n    (state: EditorState, transaction: Transaction) => {\n      const newState = state.update(transaction).state;\n      if (transaction.docChanged && options.callback) {\n        options.callback(newState.sliceDoc());\n      }\n      return newState;\n    },\n    undefined,\n    () =>\n      EditorState.create({\n        doc: options.doc,\n        extensions: [\n          basicSetup,\n          highlighter,\n          oneDark,\n          keymap.of(commentKeymap),\n        ],\n      })\n  );\n\n  useEffect(() => {\n    if (!element.current) return;\n\n    if (!view.current) {\n      view.current = new EditorView({\n        state,\n        dispatch,\n        parent: element.current\n      });\n    } else if (view.current.state !== state) {\n      // TODO: We probably want to dispatch transactions for perf,\n      // rather than completely resetting state, but the main idea\n      // is that we need to update the view to the latest state here\n      view.current.setState(state);\n    }\n\n    const container = element.current;\n    return () => {\n      if (!container) {\n        view.current?.destroy();\n        view.current = null;\n      }\n    };\n  }, [state]);\n\n  return element;\n}\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}